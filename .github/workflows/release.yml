name: Release

on:
  pull_request:
    types: [closed]
    branches: [ main ]

jobs:
  release:
    name: Branch-based Semantic Release
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Determine version bump from branch name
      id: version_bump
      run: |
        BRANCH_NAME="${{ github.head_ref }}"
        echo "Branch name: $BRANCH_NAME"
        
        if [[ $BRANCH_NAME == feat/* ]]; then
          echo "type=minor" >> $GITHUB_OUTPUT
          echo "Version bump: MINOR (new feature)"
        elif [[ $BRANCH_NAME == fix/* ]]; then
          echo "type=patch" >> $GITHUB_OUTPUT
          echo "Version bump: PATCH (bug fix)"
        elif [[ $BRANCH_NAME == breaking/* ]] || [[ $BRANCH_NAME == major/* ]]; then
          echo "type=major" >> $GITHUB_OUTPUT
          echo "Version bump: MAJOR (breaking change)"
        elif [[ $BRANCH_NAME == hotfix/* ]]; then
          echo "type=patch" >> $GITHUB_OUTPUT
          echo "Version bump: PATCH (hotfix)"
        elif [[ $BRANCH_NAME == docs/* ]]; then
          echo "type=patch" >> $GITHUB_OUTPUT
          echo "Version bump: PATCH (documentation)"
        else
          echo "type=patch" >> $GITHUB_OUTPUT
          echo "Version bump: PATCH (default)"
        fi
    
    - name: Get current version
      id: current_version
      run: |
        # Get latest tag, default to v0.0.0 if no tags exist
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "current_version=$LATEST_TAG" >> $GITHUB_OUTPUT
        echo "Current version: $LATEST_TAG"
    
    - name: Calculate new version
      id: new_version
      run: |
        CURRENT="${{ steps.current_version.outputs.current_version }}"
        TYPE="${{ steps.version_bump.outputs.type }}"
        
        # Remove 'v' prefix for calculation
        VERSION=${CURRENT#v}
        
        # Split version into parts
        IFS='.' read -ra PARTS <<< "$VERSION"
        MAJOR=${PARTS[0]:-0}
        MINOR=${PARTS[1]:-0}
        PATCH=${PARTS[2]:-0}
        
        # Bump version based on type
        if [[ $TYPE == "major" ]]; then
          MAJOR=$((MAJOR + 1))
          MINOR=0
          PATCH=0
        elif [[ $TYPE == "minor" ]]; then
          MINOR=$((MINOR + 1))
          PATCH=0
        else
          PATCH=$((PATCH + 1))
        fi
        
        NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "New version: $NEW_VERSION"
    
    - name: Create release tag
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        BRANCH_NAME="${{ github.head_ref }}"
        
        # Create release notes based on branch type
        if [[ $BRANCH_NAME == feat/* ]]; then
          RELEASE_NOTES="ðŸš€ **New Feature**

Branch: \`$BRANCH_NAME\`
Type: Feature addition (MINOR version bump)

### Changes
$(git log --oneline ${{ steps.current_version.outputs.current_version }}..HEAD)"
        elif [[ $BRANCH_NAME == fix/* ]]; then
          RELEASE_NOTES="ðŸ› **Bug Fix**

Branch: \`$BRANCH_NAME\`
Type: Bug fix (PATCH version bump)

### Changes
$(git log --oneline ${{ steps.current_version.outputs.current_version }}..HEAD)"
        elif [[ $BRANCH_NAME == breaking/* ]] || [[ $BRANCH_NAME == major/* ]]; then
          RELEASE_NOTES="ðŸ’¥ **Breaking Change**

Branch: \`$BRANCH_NAME\`
Type: Breaking change (MAJOR version bump)

âš ï¸ **This release contains breaking changes**

### Changes
$(git log --oneline ${{ steps.current_version.outputs.current_version }}..HEAD)"
        else
          RELEASE_NOTES="ðŸ“¦ **Release**

Branch: \`$BRANCH_NAME\`
Type: General update (PATCH version bump)

### Changes
$(git log --oneline ${{ steps.current_version.outputs.current_version }}..HEAD)"
        fi
        
        # Create tag
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
        git push origin "$NEW_VERSION"
        
        # Create GitHub release
        gh release create "$NEW_VERSION" \
          --title "Release $NEW_VERSION" \
          --notes "$RELEASE_NOTES"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  docker-release:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: release
    if: needs.release.outputs.new_release_published == 'true'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Login to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Get release version
      id: version
      run: echo "version=$(git describe --tags --abbrev=0)" >> $GITHUB_OUTPUT
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: .infrastructure/docker/spark.Dockerfile
        push: true
        tags: |
          ghcr.io/${{ github.repository_owner }}/joyst-spark:latest
          ghcr.io/${{ github.repository_owner }}/joyst-spark:${{ steps.version.outputs.version }}
        platforms: linux/amd64